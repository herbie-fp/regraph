#lang racket
;; code extracted and simplified from Herbie v1.4 master April 25 2020
(require math/flonum math/base math/special-functions math/bigfloat)


(provide eval-application)


(define ((comparator test) . args)
  (for/and ([left args] [right (cdr args)])
    (test left right)))

(define (from-bigfloat bff)
  (λ args (bigfloat->flonum (apply bff (map bf args)))))

(define (bffmod x mod)
  (bf- x (bf* (bftruncate (bf/ x mod)) mod)))

(define (val-to-type val)
  (cond
    [(boolean? val)
     (if val 'TRUE 'FALSE)]
    [(real? val)
     val]
    [else (error "Unknown type" val)]))

(define (no-complex fun)
  (λ xs
     (define res (apply fun xs))
     (if (real? res)
       res
       +nan.0)))

(define (if-fn test if-true if-false) (if test if-true if-false))
(define (and-fn . as) (andmap identity as))
(define (or-fn  . as) (ormap identity as))

(define (!=-fn . args)
  (not (check-duplicates args =)))

(define operator-pairs
  `((+ ,+)
    (+.c ,+)
    (- ,-)
    (neg.c ,-)
    (-.c ,-)
    (* ,*)
    (*.c ,*)
    (/ ,/)
    (/.c ,/)
    (acos ,(no-complex acos))
    (acosh ,(no-complex acosh))
    (asin ,(no-complex asin))
    (asinh ,(no-complex asinh))
    (atan ,(no-complex atan))
    (atan2 ,(no-complex atan))
    (atanh ,(no-complex atanh))
    (cbrt ,(no-complex (lambda (x) (expt x (/ 1 3)))))
    (ceil ,ceiling)
    (copysign ,(lambda (x y) (if (>= y 0) (abs x) (- (abs x)))))
    (cos ,cos)
    (cosh ,cosh)
    (erf ,(no-complex erf))
    (erfc ,erfc)
    (exp ,exp)
    (exp.c ,exp)
    (exp2 ,(no-complex (lambda (x) (expt 2 x))))
    (expm1 ,(from-bigfloat bfexpm1))
    (fabs ,abs)
    (fdim ,(lambda (x y) (max (- x y) 0)))
    (floor ,(lambda (x) (floor x)))
    (fma ,(lambda (x y z) (bigfloat->flonum (bf+ (bf* (bf x) (bf y)) (bf z)))))
    (fmax ,(lambda (x y) (cond ((nan? x) y) ((nan? y) x) (else (max x y)))))
    (fmin ,(lambda (x y) (cond ((nan? x) y) ((nan? y) x) (else (min x y)))))
    (fmod ,(from-bigfloat bffmod))
    (hypot ,(from-bigfloat bfhypot))
    (j0 ,(from-bigfloat bfbesj0))
    (j1 ,(from-bigfloat bfbesj1))
    (lgamma ,log-gamma)
    (log ,(no-complex log))
    (log.c ,log)
    (log10 ,(no-complex (lambda (x) (log x 10))))
    (log1p ,(from-bigfloat bflog1p))
    (log2 ,(from-bigfloat bflog2))
    (logb ,(lambda (x) (floor (bigfloat->flonum (bflog2 (bf (abs x)))))))
    (pow ,(no-complex expt))
    (pow.c ,expt)
    (remainder ,remainder)
    (rint ,round)
    (round ,round)
    (sin ,sin)
    (sinh ,sinh)
    (sqrt ,(no-complex sqrt))
    (sqrt.c ,sqrt)
    (tan ,tan)
    (tanh ,tanh)
    (tgamma ,gamma)
    (trunc ,truncate)
    (y0 ,(from-bigfloat bfbesy0))
    (y1 ,(from-bigfloat bfbesy1))
    (if ,if-fn)
    (== ,(comparator =))
    (complex ,make-rectangular)
    (re ,real-part)
    (im ,imag-part)
    (conj ,conjugate)
    (!= ,!=-fn)
    (< ,(comparator <))
    (> ,(comparator >))
    (<= ,(comparator <=))
    (>= ,(comparator >=))
    (not ,not)
    (and ,and-fn)
    (or ,or-fn)))

(define op-hash (make-immutable-hash operator-pairs))

(define (exact-noncomplex-value? val)
  (and (not (and (complex? val) (not (real? val))))
       (exact? val)))
 
(define (eval-application op . args)
  (if (and (not (null? args)) (andmap (conjoin number? exact?) args))
      (with-handlers ([exn:fail:contract:divide-by-zero? (const #f)])
        (define fn (first (hash-ref op-hash op)))
        (define res (apply fn args))
        
        (and (exact-noncomplex-value? res)
             (val-to-type res)))
      false))
